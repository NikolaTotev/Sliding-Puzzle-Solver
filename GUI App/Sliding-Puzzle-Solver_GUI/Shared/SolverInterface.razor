@using Sliding_Puzzle_Solver_GUI.PuzzleLogic
@using System.Drawing

<head>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons"
          rel="stylesheet">
</head>
<h3> 3x3 Auto Solver</h3>

<div class="root-grid">

    <div class="puzzle-container">
        <div class="puzzle-grid">

            @if (validMatrix)
            {
                for (int i = 0; i < 3; i++)
                {
                    for (int j = 0; j < 3; j++)
                    {
                        <div>
                            <div class="puzzle-element">@(puzzleMatrix[i][j].ElementNumber)</div>
                        </div>
                    }
                }
            }
            else
            {
                <p>Please enter a puzzle to solve</p>
            }

        </div>

    </div>

    <div class="solver-controls">
        <p>Input the puzzle matrix in the format:</p>
        <p>1 2 3, 4 5 6, 7 8 0</p>
        <p>Where 0 indicates the empty spot in the puzzle.</p>
        <input id="matrixRowInput" type="text" @bind="matrixData" />
        <input id="Button1" type="button" value="button" @onclick="@(() => StartSolving())" />
    </div>



    <div class="step-container">

        @if (isSolving)
        {
            <p>Preparing solution...</p>
        }
        else if (!isSolving && solutionReady)
        {
            @foreach (Movable step in solver.Moves)
            {
                switch (step.Direction)
                {
                    case MoveDirection.Up:
                        <div class="step">

                            <div class="step-card-grid">
                                <div class="step-puzzle-element-num">@step.PieceNumber</div>                                  
                                <span class="material-icons move-icon">
                                    expand_less
                                </span>
                            </div>
                        </div>
                        break;
                    case MoveDirection.Down:
                        <div class="step">

                            <div class="step-card-grid">
                                <div class="step-puzzle-element-num">@step.PieceNumber</div>
                                <span class="material-icons move-icon">
                                    expand_more
                                </span>
                            </div>
                        </div>
                        break;
                    case MoveDirection.Left:
                        <div class="step">
                            <div class="step-card-grid">
                                <div class="step-puzzle-element-num">@step.PieceNumber</div>                                    
                                <span class="material-icons move-icon">
                                    chevron_left
                                </span>
                            </div>
                        </div>
                        break;
                    case MoveDirection.Right:
                        <div class="step">
                            <div class="step-card-grid">
                                <div class="step-puzzle-element-num">@step.PieceNumber</div>                                 
                                <span class="material-icons move-icon">
                                    chevron_right
                                </span>
                            </div>
                        </div>
                        break;
                    case MoveDirection.None:
                        break;
                    default:
                        throw new ArgumentOutOfRangeException();
                }

            }
        }
        else
        {
            <p>Nothing to show yet.</p>
        }

    </div>
</div>






@code {

    private static List<List<int>> ThreeXThreeMatrix = new()
    {
            new List<int>() { 1, 2, 3 },
            new List<int>() { 4, 5, 6 },
            new List<int>() { 7, 8, 0 }
        };

    private static List<List<PuzzleElement>> puzzleMatrix;
    private Dictionary<int, Point> targetNumberPosition;
    private static Dictionary<int, PuzzleElement> puzzleList;
    private static int puzzleSize = 0;
    private string matrixData;
    public PuzzleSolver solver;
    bool isSolving = false;
    bool validMatrix = false;
    bool solutionReady = false;

    private async Task StartSolving()
    {
        puzzleMatrix = new List<List<PuzzleElement>>();
        puzzleList = new Dictionary<int, PuzzleElement>();
        List<string> rows = matrixData.Split(',').ToList();
        targetNumberPosition = GenTargetPositionList(SelectTargetMatrix());
        for (int j = 0; j < 3; j++)
        {
            List<int> numbers = rows[j].Split(' ').Select(int.Parse).ToList();
            List<PuzzleElement> rowToAdd = new List<PuzzleElement>();

            for (int i = 0; i < numbers.Count; i++)
            {
                Point currentCoord = new Point(i, j);
                PuzzleElement elementToAdd =
                    new PuzzleElement(numbers[i], currentCoord, targetNumberPosition[numbers[i]]);
                rowToAdd.Add(elementToAdd);
                puzzleList.Add(numbers[i], elementToAdd);
            }
            puzzleMatrix.Add(rowToAdd);
        }

        solver = new PuzzleSolver(3, puzzleMatrix, puzzleList);

        validMatrix = true;
        StateHasChanged();

        isSolving = true;
        Task task = Task<bool>.Factory.StartNew(() => solver.Solve());
        task.Wait();
        isSolving = !task.IsCompleted;
        solutionReady = true;
        StateHasChanged();
    }

    public static Dictionary<int, Point> GenTargetPositionList(List<List<int>> templateMatrix)
    {
        Dictionary<int, Point> targetPositionList = new Dictionary<int, Point>();

        for (int i = 0; i < templateMatrix.Count; i++)
        {
            for (int j = 0; j < templateMatrix[i].Count; j++)
            {
                Point currentCoord = new Point(j, i);
                targetPositionList.Add(templateMatrix[i][j], currentCoord);
            }
        }

        return targetPositionList;
    }

    public static List<List<int>> SelectTargetMatrix()
    {
        return ThreeXThreeMatrix;
    }

}
